# AI Development Foundations ü§ñ

<Callout type="info">
**Mission:** Master the universal foundations of AI-native development. Understand MCP, context management, and security principles that apply to ANY AI coding tool.

‚è≥ **Reading Time:** 35 min | üß™ **[2] Labs Included**
</Callout>

<VideoSwitcher alternatives={[{"id":"kQmXtrmQ5Zg","title":"MCP Full Workshop","author":"Anthropic","lang":"en"},{"id":"GuTcle5edjk","title":"You NEED to Learn MCP NOW!","author":"NetworkChuck","lang":"en"},{"id":"MsQACpcuTkU","title":"AI in Terminal - The Right Way","author":"NetworkChuck","lang":"en"},{"id":"HIp8sFB2GGw","title":"Cursor 2.0 - 5 Things You Didn't Know","author":"Fireship","lang":"en"}]} />

## ‚ö° Why AI Projects Stall

**"AI swallowed the internet, and now we're trying to jam AI into the existing enterprise."** ‚Äî IBM Technology

The teams that struggle aren‚Äôt using ‚Äúbad‚Äù models. They‚Äôre using AI the *wrong way*.

In 2025, the shift from **AI‚Äëassisted** to **AI‚Äënative** development is accelerating. GitHub research found developers completed tasks **55% faster** with Copilot. Anthropic introduced **MCP** as an open standard that connects models to tools and data ‚Äî and the ecosystem is growing quickly.

This isn't about learning another tool. It's about understanding the **universal principles** that make AI development work ‚Äî principles that apply whether you use Cursor, Claude Code, Windsurf, or any tool that comes next.

---

## 1. The Paradigm Shift: Writer ‚Üí Director üé¨

The most successful AI developers aren't better coders. They're better **directors**.

<Diagram type="paradigm-shift-pyramid" />

### Evolution of the Developer Role

| Era | Role | Primary Skill | Tools |
|-----|------|---------------|-------|
| **Pre-2020** | Code Writer | Syntax, algorithms | IDE, Stack Overflow |
| **2021-23** | AI User | Copy-paste prompts | ChatGPT, Copilot |
| **2024** | Prompt Engineer | Context crafting | Cursor, Claude |
| **2025+** | Agent Director | Orchestration, verification | MCP, multi-agent systems |

<ConceptCard title="Agent Director" icon="üé¨">
A developer who focuses on **architecture**, **context management**, and **verification** rather than writing syntax.

The role shifts from "how do I code this?" to **"how do I direct AI to code this correctly?"**

Your job is no longer to write code. It's to:
1. **Provide context** so AI understands the goal
2. **Verify output** for correctness and security
3. **Orchestrate tools** for complex workflows
</ConceptCard>

### Director's QA Checklist

Before accepting ANY AI-generated code, run these three tests:

| Test | Question to Ask | Red Flag |
|------|-----------------|----------|
| **Intent Check** | "Does this solve what I actually asked for?" | AI solved a different problem |
| **Security Scan** | "Did it touch auth, env, or external APIs?" | Unexpected permission changes |
| **Integration Test** | "Does it break existing functionality?" | Missing error handling, type mismatches |

<Callout type="warning">
**The Director's First Rule:** AI is a brilliant intern with no memory. It will confidently produce wrong code. Your job is to catch it before production.
</Callout>

---

## 2. MCP: The Universal Protocol üîå

**Model Context Protocol (MCP)** is to AI what USB-C is to devices ‚Äî a universal standard that connects any AI client to any capability.

<Callout type="info">
**Source:** Anthropic introduced MCP as an open standard for connecting models to tools and data (Nov 2024).
</Callout>

<Diagram type="mcp-architecture" />

### Why MCP Changed Everything

Before MCP, every AI tool had custom integrations. Cursor had its own codebase indexing. ChatGPT plugins were proprietary. Every IDE reinvented the wheel.

MCP provides **one protocol** that works everywhere:
- Write a server once ‚Üí works with Claude, Cursor, Windsurf, Antigravity
- No vendor lock-in
- Community-driven ecosystem

### The Three Interfaces of MCP

<Diagram type="mcp-capability-types" />

| Interface | Controlled By | Purpose | Example |
|-----------|---------------|---------|---------|
| **Tools** | Model (LLM) | Executable actions | `git_commit`, `query_database` |
| **Resources** | Application | Passive data | File contents, log files |
| **Prompts** | User | Templates | Slash commands like `/analyze` |

<Callout type="tip">
**Key insight:** Tools are what the AI *does*. Resources are what the AI *reads*. Prompts are what the user *triggers*.
</Callout>

### The MCP Ecosystem (2025)

<Diagram type="mcp-ecosystem-map" />

| Category | Notable Servers | Use Case |
|----------|-----------------|----------|
| **Code** | GitHub, GitLab | PRs, issues, commits |
| **Data** | Postgres, Firestore | Database queries |
| **Files** | Filesystem, Obsidian | Local file access |
| **Web** | Fetch, Brave Search | Web content |
| **Cloud** | Cloudflare, Stripe | API integrations |
| **Security** | Kali Linux (Docker) | Pen testing tools |

**The ecosystem is growing fast:**
- Community servers across code, data, and web
- Official integrations from Cloudflare, Stripe, and more
- Agent‚Äëframework adapters (e.g., LangGraph)
- Registry and discovery tooling maturing

### Production-Ready MCP

MCP has evolved from localhost demos to production infrastructure:

| Aspect | 2024 (Early) | 2025 (Now) |
|--------|--------------|------------|
| **Transport** | stdio only | Streamable HTTP, SSE |
| **Auth** | None | OAuth 2.0 official support |
| **Deployment** | localhost | Cloudflare Workers, Docker |
| **Monitoring** | Manual | Sentry integration |
| **Discovery** | Manual | Registry API (coming) |

<Callout type="warning">
**Security evolution:** Production MCP servers now require proper authentication. If you're building a server that accesses sensitive data, implement OAuth or similar before deploying remotely.
</Callout>

### When to Use (and Avoid) MCP

MCP is powerful, but not always the right choice:

| ‚úÖ **Use MCP When** | ‚ùå **Avoid MCP When** |
|---------------------|----------------------|
| Connecting to databases, APIs, or external services | Simple file operations (use built-in tools) |
| Sharing capabilities across multiple AI clients | One-off automation scripts |
| Building reusable, production-grade integrations | Quick prototypes (direct API calls are faster) |
| You need audit logging and access control | The service already has a ChatGPT plugin |

<Callout type="info">
**Cost awareness:** MCP adds latency (~50-200ms per tool call) and complexity. For simple tasks, direct integration is often faster. MCP shines when you need **reusability** and **security controls**.
</Callout>

---

## 3. Context Management Principles üß†

If the LLM is the engine, **context is the fuel**. Every AI tool uses context differently, but the principles are universal.

<Diagram type="context-hierarchy" />

### The Three Layers of Context

| Layer | Scope | Persistence | Example |
|-------|-------|-------------|---------|
| **Project Constitution** | Entire project | Permanent | CLAUDE.md, .cursorrules |
| **Task Context** | Current session | Temporary | Inline comments, task descriptions |
| **Dynamic Context** | Real-time | Ephemeral | MCP resources, file reads |

### Universal Context File Pattern

Every AI IDE supports some form of project context file:

| IDE | File | Location |
|-----|------|----------|
| Claude Code | `CLAUDE.md` | Repo root |
| Cursor | `.cursorrules` | Repo root |
| Windsurf | `.windsurfrules` | Repo root |
| Codex | `CODEX.md` (plus `AGENTS.md` for repo rules) | Repo root |
| Gemini CLI | `GEMINI.md` | Repo root |

**The content structure is universal:**

```text
# Project Constitution

## Tech Stack
- Framework: Next.js 15 (App Router)
- Database: PostgreSQL + Prisma
- Styling: Tailwind CSS + shadcn/ui

## Absolute Rules
- NEVER commit secrets or API keys
- ALWAYS use TypeScript strict mode
- ALWAYS handle errors with try/catch

## Coding Standards
- Components: PascalCase
- Functions: camelCase
- Files: kebab-case

## Architecture
[Project-specific patterns and decisions]
```

<Callout type="tip">
**Pro tip from NetworkChuck:** Keep your context files synced across tools. A "session closer" agent can update all context files (`CLAUDE.md`, `GEMINI.md`, `CODEX.md`, `AGENTS.md`) at the end of each work session, ensuring all tools share the same project state.
</Callout>

### Token Budget Reality

Context isn't free. Every token you feed the LLM costs money and reduces the space available for reasoning.

| Model | Context Window | Cost Notes |
|-------|---------------|-----------|
| Claude Opus 4.5 / Sonnet 4 | 200k+ | Pricing changes often |
| GPT‚Äë5 family | 128k+ | Pricing changes often |
| Gemini 3 Pro | 1M+ | Pricing changes often |
| Claude Code | 200k + summary | Session-based |

**Practical implications:**
- A 10,000-line codebase = ~40,000 tokens (20% of Claude's window)
- Your `CLAUDE.md` should be **under 500 lines** (keep it focused)
- Use `@file` references instead of pasting entire files

<Callout type="warning">
**The Token Trap:** Bigger context windows don't mean better results. After ~50k tokens, model performance degrades. Be surgical with what you include.
</Callout>

### Context Management Patterns

**Pattern 1: The Memory File**

For long-running projects, maintain a lessons-learned file:

```text
# .ai-context/MEMORY.md

## Lessons Learned
- 2025-01: Prisma migrations must be idempotent
- 2025-03: Redis cache TTL max 1 hour for this project
- 2025-06: Never use `any` in API responses
```

**Pattern 2: Task-Specific Context**

Inject context for complex tasks:

```text
# Context for this refactor
Current: JWT in localStorage (security risk)
Goal: HttpOnly cookies + refresh token rotation
Constraint: Must maintain mobile app compatibility
```

---

## 4. IDE Selection Framework üîß

With so many AI coding tools available, knowing when to use each one is a critical skill.

<Diagram type="ide-selection-decision-tree" />

### Decision Matrix

| Scenario | Best Tool | Why |
|----------|-----------|-----|
| **Quick prototype** | Antigravity | Fastest path to deployed app |
| **Daily coding** | Cursor 2.0 | Speed + familiar IDE + multi-agent |
| **Large refactor** | Windsurf | Deep context understanding |
| **Architecture planning** | Claude Code | Superior reasoning + Plan Mode |
| **Performance critical** | Zed | Native speed, minimal overhead |
| **Terminal workflow** | Claude Code CLI | Project-aware, agent delegation |

### Cursor 2.0 Highlights

The latest Cursor release introduced game-changing features:

| Feature | What It Does |
|---------|--------------|
| **Multi-Agent Parallelism** | Run Claude, GPT, Composer on same task via Git work trees |
| **Composer Model** | Proprietary model, significantly faster |
| **Native Browser** | Integrated browser reduces context switching |
| **Agent View Mode** | New UI for chat-heavy development |

### Terminal AI Tools

**"If you're still using AI in the browser, you're doing it the slow way."** ‚Äî NetworkChuck

| Tool | Strength | Best For |
|------|----------|----------|
| **Claude Code CLI** | Agent delegation, Plan Mode | Deep work, complex tasks |
| **Gemini CLI** | Generous free tier | General development |
| **Codex (OpenAI)** | High-level analysis | Reviewing work, critiques |

**Multi-tool strategy:**
1. Use Claude and Gemini for generative deep work
2. Use Codex for high-level review and critique
3. Keep context files synced across all tools

---

## 5. Security Fundamentals üîí

AI agents with shell and database access are powerful ‚Äî and dangerous. Security must be proactive, not reactive.

### The $50,000 MCP Incident

> *"I told Claude to clean up old test data. It ran `DROP TABLE users` in production."*

This actually happened. A developer connected an MCP server with database access to their production environment. The AI, trying to be helpful, identified "test_" prefixed records and decided to clean them up. The `test_users` table was real.

**What went wrong:**
1. ‚ùå MCP server had full `DELETE` permissions
2. ‚ùå No confirmation required for destructive operations
3. ‚ùå Production credentials in development environment
4. ‚ùå No audit log to see what was happening

**How to prevent it:**
1. ‚úÖ Read-only permissions by default
2. ‚úÖ `requires_approval: true` for DELETE/DROP/TRUNCATE
3. ‚úÖ Separate credentials for dev/staging/prod
4. ‚úÖ Audit logging on all database operations

This is why the security principles below aren't optional ‚Äî they're the difference between a helpful AI and a costly disaster.

<Diagram type="ai-security-layers" />

### The Four Security Principles

| Principle | Implementation |
|-----------|----------------|
| **Least Privilege** | Grant minimal permissions needed |
| **Sandboxing** | Run MCP servers in Docker containers |
| **Audit Logging** | Log all tool invocations and outputs |
| **Human-in-the-Loop** | Critical operations require approval |

### Production Security Checklist

For any MCP server in production:

- [ ] OAuth 2.0 authentication configured
- [ ] Role-based access control (RBAC) implemented
- [ ] Input validation and SQL sanitization
- [ ] Application monitoring (Sentry, etc.)
- [ ] Lifecycle management for resources
- [ ] Network isolation where possible

### Red Flags to Watch

<Callout type="warning">
**Immediately disable an MCP server if it:**
- Tries to read `.env` or credential files
- Calls unexpected API endpoints
- Generates code with `eval()` or `exec()`
- Requests permission escalation
- Attempts to modify system files outside project
</Callout>

### Example: Docker Sandbox

```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt

# Security: No network unless explicitly required
# Communication only via stdio
USER nobody
CMD ["python", "server.py"]
```

---

## üß™ Lab 1: Build Your First MCP Server

### üéØ Goal

Create a custom MCP server that extends AI capabilities.

### üìã Prerequisites

- Python 3.10+
- Claude Desktop, Cursor, or any MCP client

<Callout type="info">
**Why this matters:** Understanding how to build MCP servers is the foundation for extending any AI tool's capabilities. This skill transfers to every MCP-compatible client.
</Callout>

### üõ†Ô∏è Steps

**Step 1: Install Dependencies**

```bash
pip install mcp[cli] psutil
```

**Step 2: Create Server**

Create `monitor_server.py`:

```python
from mcp.server.fastmcp import FastMCP
import psutil

mcp = FastMCP("SystemMonitor")

@mcp.tool()
def get_system_stats() -> str:
    """Returns CPU and RAM usage.
    Use when user asks about system performance."""
    cpu = psutil.cpu_percent(interval=1)
    ram = psutil.virtual_memory().percent
    return f"CPU: {cpu}%\nRAM: {ram}%"

@mcp.tool()
def get_disk_usage() -> str:
    """Returns disk usage for all partitions."""
    partitions = psutil.disk_partitions()
    result = []
    for p in partitions:
        try:
            usage = psutil.disk_usage(p.mountpoint)
            result.append(f"{p.mountpoint}: {usage.percent}%")
        except:
            pass
    return "\n".join(result)

if __name__ == "__main__":
    mcp.run()
```

**Step 3: Configure Client**

For Claude Desktop, edit `claude_desktop_config.json`:
- **macOS:** `~/Library/Application Support/Claude/claude_desktop_config.json`
- **Windows:** `%APPDATA%\Claude\claude_desktop_config.json`

```json
{
  "mcpServers": {
    "system-monitor": {
      "command": "python",
      "args": ["/absolute/path/to/monitor_server.py"]
    }
  }
}
```

**Step 4: Test**

1. Restart your MCP client
2. Look for the üîå icon showing connected servers
3. Ask: "How is my system doing?" or "Check disk space"

### ‚úÖ Success Criteria

- [x] Server starts without errors
- [x] Client recognizes the server
- [x] Tools return live system data

**üí° Aha Moment:** "I just extended my AI's capabilities with custom tools. This same pattern works for connecting AI to databases, APIs, or any system I need."

<LabComplete labId="lab-mcp-server" />

---

## üß™ Lab 2: Create Your Project Constitution

### üéØ Goal

Create a universal context file that works with any AI IDE.

### üìã Prerequisites

- Any AI coding tool (Claude Code, Cursor, etc.)
- A project to work on (or create a new one)

### üõ†Ô∏è Steps

**Step 1: Generate Template**

Use this prompt with any AI tool:

```text
You are a project context specialist. Create a universal context file
for a [YOUR PROJECT TYPE - e.g., "Next.js SaaS application"] that includes:

1. Tech Stack section (list all technologies)
2. Coding Standards section (naming, patterns)
3. Absolute Rules section (NEVER/ALWAYS statements)
4. Architecture section (key patterns and decisions)
5. Security section (sensitive areas, auth patterns)

Format it to work for CLAUDE.md, .cursorrules, or .windsurfrules.
Make rules specific and actionable, not generic.
```

**Step 2: Save as Constitution**

Save the output as your primary context file:
- `CLAUDE.md` for Claude Code
- `.cursorrules` for Cursor
- `.windsurfrules` for Windsurf

**Step 3: Test Context Loading**

Start a new session and ask: "What are the coding standards for this project?"

The AI should reference your constitution without you providing additional context.

**Step 4: Cross-Tool Sync (Optional)**

If using multiple tools, copy the core content to all context files. Add a comment header:

```text
# Last synced: 2025-01-15
# Source of truth: CLAUDE.md
```

### ‚úÖ Success Criteria

- [x] Context file contains all 5 sections
- [x] Rules are specific, not generic
- [x] AI correctly references rules without prompting
- [x] (Bonus) Synced across multiple tools

**üí° Aha Moment:** "My AI now knows my project's standards automatically. I'm spending less time explaining context and more time building features."

<LabComplete labId="lab-project-constitution" />

---

## üèÜ Holocron: AI Development Foundations

<ConceptCard title="Holocron: AI Development Foundations" icon="üíé">

### üîë Key Takeaways

1. üé¨ **You're now a Director.** Stop writing code; start directing AI to write code correctly.
2. üîå **MCP is the universal standard.** Open, production‚Äëready, and growing fast.
3. üß† **Context is everything.** Project constitution + memory files = intelligent AI.
4. üîí **Security first.** Least privilege, sandboxing, audit logs, human-in-the-loop.

### üõ†Ô∏è Your Foundation Stack

```text
Protocol:   MCP (open standard, growing ecosystem)
Context:    Project Constitution + Memory Files
Security:   Docker sandbox + OAuth + Audit
Tools:      Pick per task (Cursor daily, Claude Code for depth)
Workflow:   Synced context across all tools
```

### üìã Quick Reference

| Concept | Implementation |
|---------|----------------|
| MCP Server | FastMCP + tool decorators |
| Context File | CLAUDE.md / .cursorrules |
| Security | Docker + least privilege |
| Multi-tool | Synced context files |

### üöÄ What's Next?

This lesson gave you the **foundations**. The next lessons dive deep into specific tools:
- **Lesson 06:** Claude Code Mastery
- **Lesson 07:** Antigravity Mastery
- **Future:** Cursor Mastery, Windsurf Mastery

</ConceptCard>

---

<Callout type="success">
üéâ **Congratulations!** You've mastered the universal foundations of AI-native development. These principles work with any tool, today and in the future.
</Callout>

**Next steps:**
- Complete Lesson 06: Claude Code Mastery for deep-dive on terminal AI
- Try Lesson 07: Antigravity Mastery for rapid prototyping
- Build 2-3 custom MCP servers for your workflow
