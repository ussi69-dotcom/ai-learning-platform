import { useState, useRef, useEffect, useCallback } from 'react';
import { ABTestPhase } from './abTestPhases';

interface UseABTestAnimationProps {
  phases: ABTestPhase[];
  isExpanded: boolean;
}

interface UseABTestAnimationReturn {
  currentPhase: number;
  visibleMessagesInPhase: number;
  isAutoPlaying: boolean;
  isUserPaused: boolean;
  isResuming: boolean;
  scrollRef: React.RefObject<HTMLDivElement | null>;
  handleScroll: () => void;
  handleResume: () => void;
  handleManualChange: (newPhase: number) => void;
  handleManualNext: () => void;
  handleManualPrev: () => void;
  resetAnimation: () => void;
}

export function useABTestAnimation({ phases, isExpanded }: UseABTestAnimationProps): UseABTestAnimationReturn {
  const [currentPhase, setCurrentPhase] = useState(0);
  const [visibleMessagesInPhase, setVisibleMessagesInPhase] = useState(0);
  const [isAutoPlaying, setIsAutoPlaying] = useState(true);
  const [isResuming, setIsResuming] = useState(false);
  const [isUserPaused, setIsUserPaused] = useState(false);

  const scrollRef = useRef<HTMLDivElement>(null);
  const animationFrameRef = useRef<number | null>(null);
  const interactionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const isProgrammaticScrollRef = useRef(false);

  // Cleanup helper
  const cancelScrollAnimation = useCallback(() => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }
  }, []);

  // Track last scroll position to detect user scroll direction
  const lastScrollTopRef = useRef(0);

  // Handle User Scroll Interaction
  const handleScroll = useCallback(() => {
    if (!scrollRef.current) return;

    const currentScrollTop = scrollRef.current.scrollTop;
    const scrollingUp = currentScrollTop < lastScrollTopRef.current - 1; // 1px threshold for mouse wheel
    lastScrollTopRef.current = currentScrollTop;

    // If programmatic scroll is running but user scrolls UP, they want to read - interrupt!
    if (isProgrammaticScrollRef.current && scrollingUp) {
      cancelScrollAnimation();
      isProgrammaticScrollRef.current = false;
      setIsUserPaused(true);

      if (interactionTimeoutRef.current) {
        clearTimeout(interactionTimeoutRef.current);
      }
      interactionTimeoutRef.current = setTimeout(() => {
        setIsUserPaused(false);
        interactionTimeoutRef.current = null;
      }, 2000);
      return;
    }

    // Ignore scroll events generated by programmatic scrolling
    if (isProgrammaticScrollRef.current) return;

    if (isAutoPlaying) {
      cancelScrollAnimation();

      if (!isUserPaused) {
        setIsUserPaused(true);
      }

      if (interactionTimeoutRef.current) {
        clearTimeout(interactionTimeoutRef.current);
      }

      interactionTimeoutRef.current = setTimeout(() => {
        setIsUserPaused(false);
        interactionTimeoutRef.current = null;
      }, 2000);
    }
  }, [isAutoPlaying, isUserPaused, cancelScrollAnimation]);

  // Scroll behavior effect
  useEffect(() => {
    if (!scrollRef.current || !isAutoPlaying || visibleMessagesInPhase === 0 || isUserPaused) return;

    const scrollToNewMessage = async () => {
      if (!scrollRef.current) return;

      await new Promise(resolve => setTimeout(resolve, 800));

      if (!scrollRef.current || !isAutoPlaying || isUserPaused) return;

      const currentPhaseData = phases[currentPhase];
      const currentMessage = currentPhaseData.messages[visibleMessagesInPhase - 1];

      if (currentMessage) {
        const wordCount = currentMessage.message.split(/\s+/).length;
        const timingMod = (currentMessage.timingModifier ?? 0) * 1000;
        // 2x slower scroll (7.5 words/sec instead of 15) + timing modifier
        const scrollDuration = Math.max(1000, (wordCount / 7.5) * 1000 + (timingMod > 0 ? timingMod * 2 : 0));

        const targetScroll = scrollRef.current.scrollHeight - scrollRef.current.clientHeight;

        if (targetScroll > scrollRef.current.scrollTop) {
          const scrollContainer = scrollRef.current;
          scrollContainer.style.scrollBehavior = 'auto';

          const startScroll = scrollContainer.scrollTop;
          const distance = targetScroll - startScroll;
          const startTime = performance.now();

          isProgrammaticScrollRef.current = true;

          const animateScroll = (currentTime: number) => {
            if (!scrollRef.current || isUserPaused) {
              isProgrammaticScrollRef.current = false;
              return;
            }

            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / scrollDuration, 1);

            const easeProgress = progress < 0.5
              ? 2 * progress * progress
              : 1 - Math.pow(-2 * progress + 2, 2) / 2;

            scrollRef.current.scrollTop = startScroll + (distance * easeProgress);

            if (progress < 1 && isAutoPlaying && !isUserPaused) {
              animationFrameRef.current = requestAnimationFrame(animateScroll);
            } else {
              isProgrammaticScrollRef.current = false;
            }
          };

          animationFrameRef.current = requestAnimationFrame(animateScroll);
          await new Promise(resolve => setTimeout(resolve, scrollDuration));
        }
      }

      const isLastMessage = visibleMessagesInPhase === currentPhaseData.messages.length;
      let bottomPause = 3000;

      if (isLastMessage && currentMessage) {
        const wordCount = currentMessage.message.split(/\s+/).length;
        const pauseMod = (currentMessage.timingModifier ?? 0) * 1000;
        // Negative modifier = shorter pause (faster transition)
        bottomPause = Math.max(2000, Math.min(7000 + (wordCount / 15) * 1000 + pauseMod, 10000));
      } else if (currentMessage) {
        const wordCount = currentMessage.message.split(/\s+/).length;
        const pauseMod = (currentMessage.timingModifier ?? 0) * 1000;
        // Negative modifier = shorter pause
        bottomPause = Math.max(1000, Math.min(3000 + (wordCount / 15) * 1000 + pauseMod, 5000));
      }

      await new Promise(resolve => setTimeout(resolve, bottomPause));
    };

    scrollToNewMessage();

    return () => {
      cancelScrollAnimation();
      isProgrammaticScrollRef.current = false;
    };
  }, [visibleMessagesInPhase, isAutoPlaying, currentPhase, isUserPaused, phases, cancelScrollAnimation]);

  // Reset visible messages when phase changes
  useEffect(() => {
    setVisibleMessagesInPhase(0);
  }, [currentPhase]);

  // Progressive message reveal
  useEffect(() => {
    if (!isExpanded || !isAutoPlaying || isUserPaused) return;

    const currentPhaseData = phases[currentPhase];
    const totalMessagesInPhase = currentPhaseData.messages.length;

    if (visibleMessagesInPhase === 0) {
      const timer = setTimeout(() => {
        setVisibleMessagesInPhase(1);
      }, 500);
      return () => clearTimeout(timer);
    }
    else if (visibleMessagesInPhase < totalMessagesInPhase) {
      const currentMessage = currentPhaseData.messages[visibleMessagesInPhase - 1];
      const wordCount = currentMessage.message.split(/\s+/).length;
      const timingMod = (currentMessage.timingModifier ?? 0) * 1000;
      // 2x slower scroll (7.5 words/sec) + timing modifier doubled for positive values
      const scrollTime = Math.max(1000, (wordCount / 7.5) * 1000 + (timingMod > 0 ? timingMod * 2 : 0));
      const pauseAtBottom = Math.max(1000, Math.min(3000 + (wordCount / 15) * 1000 + timingMod, 5000));
      const totalDelay = 800 + scrollTime + pauseAtBottom;

      const timer = setTimeout(() => {
        setVisibleMessagesInPhase(prev => prev + 1);
      }, totalDelay);

      return () => clearTimeout(timer);
    } else {
      const lastMessage = currentPhaseData.messages[totalMessagesInPhase - 1];
      const wordCount = lastMessage.message.split(/\s+/).length;
      const timingMod = (lastMessage.timingModifier ?? 0) * 1000;
      // 2x slower scroll for phase transition
      const scrollTime = Math.max(1000, (wordCount / 7.5) * 1000 + (timingMod > 0 ? timingMod * 2 : 0));
      const bottomPause = Math.max(2000, Math.min(7000 + (wordCount / 15) * 1000 + timingMod, 10000));

      const totalDelay = 800 + scrollTime + bottomPause;

      if (currentPhase < phases.length - 1) {
        const timer = setTimeout(() => {
          setCurrentPhase(prev => prev + 1);
        }, totalDelay);

        return () => clearTimeout(timer);
      } else {
        const timer = setTimeout(() => {
          setIsAutoPlaying(false);
        }, totalDelay);

        return () => clearTimeout(timer);
      }
    }
  }, [isExpanded, isAutoPlaying, currentPhase, visibleMessagesInPhase, isUserPaused, phases]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cancelScrollAnimation();
      if (interactionTimeoutRef.current) {
        clearTimeout(interactionTimeoutRef.current);
      }
    };
  }, [cancelScrollAnimation]);

  const handleResume = useCallback(() => {
    setIsResuming(true);
    setIsUserPaused(false);
    setTimeout(() => {
      setIsResuming(false);
      setIsAutoPlaying(true);
    }, 2000);
  }, []);

  const handleManualChange = useCallback((newPhase: number) => {
    setIsAutoPlaying(false);
    setIsResuming(false);
    setIsUserPaused(false);
    setCurrentPhase(newPhase);
    setVisibleMessagesInPhase(phases[newPhase].messages.length);
  }, [phases]);

  const handleManualNext = useCallback(() => {
    setIsAutoPlaying(false);
    if (currentPhase < phases.length - 1) {
      const nextPhase = currentPhase + 1;
      setCurrentPhase(nextPhase);
      setVisibleMessagesInPhase(phases[nextPhase].messages.length);
    }
  }, [currentPhase, phases]);

  const handleManualPrev = useCallback(() => {
    setIsAutoPlaying(false);
    if (currentPhase > 0) {
      const prevPhase = currentPhase - 1;
      setCurrentPhase(prevPhase);
      setVisibleMessagesInPhase(phases[prevPhase].messages.length);
    }
  }, [currentPhase, phases]);

  const resetAnimation = useCallback(() => {
    setCurrentPhase(0);
    setVisibleMessagesInPhase(0);
    setIsAutoPlaying(true);
    setIsUserPaused(false);
    setIsResuming(false);
  }, []);

  return {
    currentPhase,
    visibleMessagesInPhase,
    isAutoPlaying,
    isUserPaused,
    isResuming,
    scrollRef,
    handleScroll,
    handleResume,
    handleManualChange,
    handleManualNext,
    handleManualPrev,
    resetAnimation,
  };
}
